# Forge-Secure-Notes-for-Jira

[![Node.js CI](https://github.com/vzakharchenko/Forge-Secure-Notes-for-Jira/actions/workflows/node.js.yml/badge.svg)](https://github.com/vzakharchenko/Forge-Secure-Notes-for-Jira/actions/workflows/node.js.yml)
[![Snyk Vulnerabilities](https://snyk.io/test/github/vzakharchenko/Forge-Secure-Notes-for-Jira/badge.svg)](https://snyk.io/test/github/vzakharchenko/Forge-Secure-Notes-for-Jira)
[![DeepScan grade](https://deepscan.io/api/teams/26652/projects/30673/branches/987394/badge/grade.svg)](https://deepscan.io/dashboard#view=project&tid=26652&pid=30673&bid=987394)

![GitHub License](https://img.shields.io/github/license/vzakharchenko/Forge-Secure-Notes-for-Jira)

![GitHub repo size](https://img.shields.io/github/repo-size/vzakharchenko/Forge-Secure-Notes-for-Jira)

Share sensitive information securely within Jira issues. Create one-time, expiring encrypted notes with out-of-band key exchange. Built with Atlassian Forge, Custom UI &amp; @forge/sql, @forge/kvs.

## üß† About the Project

### Inspiration

"Secure Notes for Jira" was inspired by a common challenge faced by many teams: the need to share sensitive information ‚Äî such as access credentials, API keys, private feedback, or temporary passwords ‚Äî directly within a Jira issue, without exposing it in issue fields, comments, or descriptions.

While Jira excels at task tracking and collaboration, it lacks a secure, ephemeral channel for confidential communication. This app bridges that gap by providing a secure mechanism for sharing notes that are:

- Confidential
- Time-limited
- Verifiably read by the intended recipient
- Automatically deleted after viewing

### üîí Security Features

- üîê Create encrypted notes on Jira issues
- üïí Choose an expiration: 1 hour, 1 day, 7 days, 10 days
- üîë Generate a one-time decryption key (created by user, never stored on backend - only the user knows the key)
- üì• View received notes (with key)
- üì§ View and delete sent notes
- üß® Note self-destructs after reading or upon expiry
- ‚è≥ Expiration is enforced automatically using a Forge `scheduledTrigger`
- üë§ Only the designated Atlassian account can decrypt the Secure Note
- üìß **Email Notifications**: Automatic email notifications are sent:
  - When a secure note is created and shared with you
  - When a secure note expires and is automatically deleted
  - When a secure note is manually deleted by the creator

### üñ• UI Features

- üìé Open decryption links directly from the Issue Panel or via email
- üß≠ Support for routing and deep-linking to global pages
- ‚è±Ô∏è 5-minute countdown timer during note viewing
- üåì Full dark/light mode support based on Jira theme
- üë• Multiple recipients support - send secure notes to multiple users at once
- üìù Description field for better note organization and tracking
- üìä Comprehensive audit pages with detailed history tracking:
  - **My History**: View your personal secure notes history with pagination
  - **My Issue History**: Browse notes by issue with detailed audit trails
  - **My Project History**: View notes organized by project
  - **User History**: Admin-only view of all users' secure notes
- üìà Expandable status history showing CREATED, VIEWED, DELETED, and EXPIRED events
- üì• CSV Export functionality on all audit pages for data analysis
- üîÑ Automatic background polling (every 10 seconds) for real-time updates
- üìã Modern table UI using Atlassian Design System components
- ü§ñ **Rovo AI Agent** - Natural language analytics for Security Notes data

## üõ† Technical Implementation

### Architecture

The project follows a clean architecture pattern with clear separation of concerns:

- **Frontend:** React + Vite (Forge Custom UI)
- **Backend:** Forge Functions using `@forge/api`, `@forge/sql`, `@forge/kvs`
- **ORM:** [forge-sql-orm](https://github.com/vzakharchenko/forge-sql-orm)
- **AI Analytics:** Atlassian Rovo AI agent for natural language queries
- **Storage:**
  - Encrypted content in `@forge/kvs` (via `setSecret`)
  - Metadata in `@forge/sql`

### Security Design

- **Client-side encryption** using Web Crypto API
- **AES-GCM** with 32-byte key derived via PBKDF2
- **Encryption key security:**
  - The encryption key is **generated by the user** and **never stored on the backend**
  - Only the user who creates the key knows it
  - Backend stores only `encryption_key_hash` (hash of the key) for validation purposes
  - The actual encryption key is required for decryption and must be shared out-of-band
- **Split data model for decryption:**
  - Half of the decryption data is with the user: **encryption key** (known only to the user)
  - Other half is in metadata: **IV** (Initialization Vector) and **salt** stored in `@forge/sql`
  - Both parts are required to decrypt the content
- Random IV generation for each message
- Encrypted content stored in `@forge/kvs.setSecret`
- Metadata (IV, salt, encryption_key_hash) stored in `@forge/sql`
- Out-of-band key exchange required (key must be shared separately via secure channel)
- Automatic content deletion after viewing

## üöÄ Getting Started

### Prerequisites

- Node.js (v20 or higher)
- npm (v7 or higher)
- Atlassian Forge CLI (`forge` command-line tool)
- A Jira Cloud instance with admin access
- Forge development environment set up

### Installation

1. Clone the repository:

```bash
git clone https://github.com/your-username/Forge-Secure-Notes-for-Jira.git
cd Forge-Secure-Notes-for-Jira
```

2. Install dependencies:

```bash
npm install
```

3. Register your Forge app:

```bash
forge register
```

4. Build UI:

```bash
cd static
npm install
npm run build
cd ..
```

5. Deploy to production:

```bash
forge deploy -e production
```

6. Install in your Jira instance:

```bash
forge install -e production
```

### Development

1. Deploy the app:

```bash
forge deploy
```

2. Install in your Jira instance:

```bash
forge install
```

3. Start the development server:

```bash
forge tunnel
```

## üìù Usage Guide

### Creating a Secure Note

1. Open any Jira issue
2. Click on the "Secure Notes" panel
3. Click "Create New Secure Note"
4. Fill in the required fields:
   - **Select recipients**: Choose one or multiple users who can decrypt the note
   - **Description**: Enter a description of what you're sharing (required)
   - **Your Secure Note**: Enter the secret message content (max 10KB recommended)
   - **Set Note Expiry**: Choose expiration time (1 hour, 1 day, 7 days, 10 days, or custom date)
5. Click "Generate New Key" to create an encryption key
6. Copy the encryption key and share it securely (via Slack, email, etc.)
7. Click "Create & Encrypt Note"
8. **Email Notification**: The recipient(s) will automatically receive an email notification with:
   - A direct link to access the secure note
   - The expiration date and time
   - Instructions on how to obtain the decryption key
9. The note will be automatically updated in the panel every 10 seconds via background polling

### Viewing a Secure Note

1. Open the secure note link (from email notification or issue panel)
2. Enter the decryption key
3. View the message content
4. Use "Copy and Close" to save the content and destroy the note
5. The note will be automatically destroyed after viewing or when expired

### Email Notifications

The application automatically sends email notifications for important events:

1. **When a Secure Note is Created**:
   - Recipients receive an email with subject "üîê A security note has been shared with you"
   - The email includes a direct link to access the note
   - The expiration date and time are clearly displayed
   - Instructions on how to obtain the decryption key are provided

2. **When a Secure Note Expires**:
   - Recipients receive an email with subject "‚ö†Ô∏è A Secure Note has expired and was deleted"
   - The email notifies that the note has been automatically deleted
   - Instructions to contact the sender if access is still needed

3. **When a Secure Note is Deleted**:
   - Recipients receive an email with subject "üóëÔ∏è A Secure Note has been deleted"
   - The email notifies that the creator has manually deleted the note
   - Instructions to contact the sender if access is still needed

**Note**: Email notifications are sent via Jira's notification system and will appear in the recipient's email inbox associated with their Jira account.

### Audit and History Pages

The application provides comprehensive audit pages accessible from the global page:

1. **My History** (`/myHistory`):
   - View all your secure notes with pagination
   - See description, status, issue/project keys, and timestamps
   - Expand rows to view status history (CREATED, VIEWED, DELETED, EXPIRED)
   - Export all data to CSV format

2. **My Issue History** (`/myIssue`):
   - Browse all issues that contain secure notes
   - Click on an issue to view detailed audit information
   - Export issue-specific data to CSV

3. **My Project History** (`/myProject`):
   - View all projects with secure notes
   - Drill down into project-specific audit details
   - Export project data to CSV

4. **User History** (`/userHistory` - Admin only):
   - Administrators can view all users' secure notes
   - Select a user to see their complete history
   - Export user-specific audit data to CSV

All audit pages feature:

- Pagination (10 items per page)
- Expandable status history rows
- CSV export functionality
- Real-time data updates

### Rovo AI Analytics

The application includes a **Rovo AI agent** that enables natural language queries about Security Notes data. Users can ask questions in plain English, and the agent will generate and execute SQL queries to provide insights.

**Features:**

- Ask questions like:
  - "Show all users which I shared security notes with for this issue"
  - "Show my notes for this issue from last week"
  - "Prepare a report of all descriptions and who shared for this issue last month"
  - "Show top 10 users who created the most security notes"

**Security:**

- Only read-only SELECT queries are allowed
- Queries must target only the `security_notes` table (no JOINs, subqueries, or references to other tables)
- JOIN operations are automatically detected and blocked using EXPLAIN query plan analysis
- Window functions (e.g., `COUNT(*) OVER(...)`) are not allowed and are automatically detected and blocked
- Non-admin users can only see notes they created or received
- Admin users have full access to all notes
- Sensitive fields are protected:
  - **Encryption key**: Never stored on backend, only known to the user who created it
  - **encryption_key_hash**: Stored for validation only (cannot be used to decrypt)
  - **IV and salt**: Stored in metadata but useless without the encryption key
  - These fields are never exposed in Rovo queries or any API responses
- Row-level security is enforced automatically
- Security columns (`created_by`, `target_user_id`) must be selected as raw columns for proper access control

**How to use:**

1. Open the Rovo AI assistant in Jira
2. Ask questions about Security Notes using natural language
3. The agent will generate SQL queries and return results
4. Results are explained in natural language with summaries and highlights

**Example queries:**

- "Can you show all users which I shared security notes with for this issue?"
- "Show all users which I shared security notes with for this project."
  - "Report security notes for this issue last month."
  - "Show me top 10 users who created the most security notes."

## üèóÔ∏è Development Architecture & Quality

### Component Structure

The codebase is organized into separate components (folders) for better maintainability and clear boundaries:

- **`src/resolvers/`** - API resolvers (handlers for Forge functions)
- **`src/services/`** - Business logic services
- **`src/database/`** - Database repositories and entities
- **`src/controllers/`** - Request controllers that coordinate services
- **`src/storage/`** - Storage abstractions (KVS operations)
- **`shared/`** - Shared contracts between frontend and backend

This separation allows for:

- Clear dependency boundaries
- Easier testing and mocking
- Better code organization
- Explicit visibility of dependencies between components

### Frontend-Backend Contract

The project uses a **shared module** (`shared/`) to define the contract between frontend and backend:

- **Resolver Names** in `shared/ResolverNames.ts` - **Centralized definition of all resolver function names**. This is the single source of truth for resolver names used by both frontend and backend. All resolver names must be defined here to ensure consistency.
- **DTOs (Data Transfer Objects)** in `shared/dto/` - Define request/response structures
- **Response Types** in `shared/responses/` - Type-safe response interfaces
- **Type Definitions** in `shared/Types.ts` - Common type definitions

**Important:** The contract uses **runtime validation** with `class-validator` because TypeScript types are erased at runtime. This means:

- All DTOs are validated using `class-validator` decorators
- Invalid requests are rejected before reaching business logic
- Type safety in TypeScript is not enough - runtime validation is essential
- This is different from languages like Java where types exist at runtime

**Resolver Names:**
All resolver function names are defined in `shared/ResolverNames.ts` as an enum. This ensures that:

- Frontend and backend use the same resolver names
- Typos and inconsistencies are prevented
- Refactoring is easier (change in one place)
- Type safety is maintained across the codebase

Example:

```typescript
// shared/ResolverNames.ts
export enum ResolverNames {
  GET_MY_SECURED_NOTES = "getMySecuredNotes",
  CREATE_SECURITY_NOTE = "createSecurityNote",
  // ... all resolver names defined here
}

// Usage in controller
functionName(): string {
  return ResolverNames.CREATE_SECURITY_NOTE;
}

// Usage in frontend
invoke(ResolverNames.CREATE_SECURITY_NOTE, payload);
```

**DTO Validation Example:**

```typescript
// shared/dto/NewSecurityNote.ts
export class NewSecurityNote {
  @IsString()
  @IsNotEmpty()
  description!: string;

  @IsString()
  @IsNotEmpty()
  encryptedData!: string;
  // ... validation ensures data integrity at runtime
}
```

### Dependency Injection (DI)

The project uses **[Inversify](https://github.com/inversify/InversifyJS)** for dependency injection, which provides several key benefits:

- **Code Separation:** DI allows clear separation of concerns and makes dependencies explicit
- **Modular Dependency Management:** Each resolver group and trigger can have its own dependency container, making it easy to see exactly which services are used in each module
- **Explicit Dependencies:** You can clearly see where specific services are used (e.g., `@src/storage/SecurityStorage.ts`) by examining the DI container setup
- **Security Boundaries:** Admin-only services can be restricted to admin modules in the manifest, preventing them from being accidentally used in non-admin resolvers
- **Testability:** Services can be easily mocked and replaced for testing

**Structure:**

- Each resolver group (`src/resolvers/global/`, `src/resolvers/issue/`) has its own `di.ts` file that sets up the dependency container
- Services are registered with injection tokens defined in `src/constants/ForgeInjectionTokens.ts`
- Controllers and services use `@injectable()` decorator and `@inject()` for dependency injection

**Example:**

```typescript
// src/resolvers/global/di.ts
export const setupContainer = (): Container => {
  const container = new Container();
  container.bind(FORGE_INJECTION_TOKENS.SecurityNoteService).to(SecurityNoteService);
  container.bind(FORGE_INJECTION_TOKENS.SecurityStorage).to(SecurityStorage);
  // ... explicit dependency registration
};
```

### Code Quality Tools

The project uses several tools to maintain code quality and consistency:

#### ESLint (Linter)

**ESLint** is a static code analysis tool that identifies problematic patterns and potential bugs in JavaScript/TypeScript code. It's crucial for maintaining code quality and consistency across the project.

**Why it's important:**

- **Catches bugs early:** Identifies potential errors before they reach production
- **Enforces coding standards:** Ensures consistent code style across the team
- **Improves code maintainability:** Helps keep code readable and maintainable
- **Prevents common mistakes:** Flags anti-patterns and problematic code structures

**Usage:**

```bash
# Run linter
npm run lint

# Fix auto-fixable issues
npm run lint:fix
```

**CI Integration:** The linter is run in CI pipelines to ensure all code meets quality standards before merging. It's also recommended to run `npm run lint` locally before committing changes to catch issues early.

#### Prettier (Code Formatter)

**Prettier** is an opinionated code formatter that enforces consistent code formatting across the project. It automatically formats code according to predefined rules, eliminating debates about code style.

**Features:**

- **Automatic formatting:** Formats code on save or via command
- **Consistent style:** Ensures all code follows the same formatting rules
- **Integration with Git hooks:** Uses `lint-staged` and `husky` to automatically format code before commits
- **Improves readability:** Consistent formatting makes code easier to read and understand

**Usage:**

```bash
# Format all files
npm run format

# Check formatting without making changes
npm run format:check
```

**Git Hooks:** Prettier is integrated with `husky` and `lint-staged` to automatically format staged files before commits, ensuring all committed code is properly formatted.

#### Knip (Dependency Checker)

**Knip** is a tool that finds unused dependencies, files, and exports in your project. It's essential for maintaining a clean dependency tree and reducing security surface area.

**Why it's important:**

- **Reduces security risk:** Unused dependencies can contain vulnerabilities that Snyk will flag, even if you're not using them
- **Cleaner dependency tree:** Helps identify and remove dependencies that are no longer needed
- **Easier security maintenance:** When using Snyk for security scanning, it's much easier to maintain security if you only have dependencies you actually use
- **Smaller bundle size:** Removing unused dependencies reduces the final bundle size

**Usage:**

```bash
# Check for unused dependencies
npm run knip
```

**Snyk Integration:** When using Snyk for security vulnerability scanning, Knip helps ensure that Snyk only checks dependencies that are actually used in the codebase. This significantly simplifies security maintenance by avoiding false positives from unused packages.

## ü§ù Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## üìÑ License

This project is licensed under the MIT License - see the LICENSE file for details.

## üí¨ Support

For support, please open an issue in the GitHub repository .
